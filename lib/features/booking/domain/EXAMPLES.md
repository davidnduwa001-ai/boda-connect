# Booking Domain Layer - Usage Examples

This document provides practical examples of using the Booking domain layer in real-world scenarios.

## Table of Contents

- [Complete Booking Flow](#complete-booking-flow)
- [Payment Scenarios](#payment-scenarios)
- [Status Management](#status-management)
- [Date Validation](#date-validation)
- [Availability Checking](#availability-checking)
- [Error Handling Patterns](#error-handling-patterns)

---

## Complete Booking Flow

### Scenario: Client Creates a Wedding Booking

```dart
import 'package:boda_connect/features/booking/domain/booking_domain.dart';

class BookingService {
  final CreateBooking _createBooking;
  final CheckAvailability _checkAvailability;

  BookingService(this._createBooking, this._checkAvailability);

  Future<Either<Failure, BookingEntity>> createWeddingBooking({
    required String clientId,
    required String supplierId,
    required String packageId,
    required DateTime weddingDate,
    required String eventName,
    required int packagePrice,
  }) async {
    // Step 1: Validate the date
    final bookingDate = BookingDate(
      eventDate: weddingDate,
      eventTime: "15:00",
    );

    // Check if date is valid for new bookings (at least 30 days advance)
    if (!bookingDate.isValidForBooking(minimumAdvanceDays: 30)) {
      return Left(ValidationFailure(
        'Casamentos devem ser agendados com pelo menos 30 dias de antecedência. '
        'Faltam apenas ${bookingDate.daysUntilEvent} dias.',
      ));
    }

    // Step 2: Check supplier availability
    final availabilityParams = CheckAvailabilityParams(
      supplierId: supplierId,
      date: weddingDate,
    );

    final availabilityResult = await _checkAvailability(availabilityParams);

    final isAvailable = await availabilityResult.fold(
      (failure) => false,
      (available) => available,
    );

    if (!isAvailable) {
      return Left(ValidationFailure(
        'Fornecedor não está disponível em ${bookingDate.formatDate()}',
      ));
    }

    // Step 3: Create the booking entity
    final totalMoney = Money(amount: packagePrice, currency: 'AOA');

    final booking = BookingEntity(
      id: '', // Will be generated by repository
      clientId: clientId,
      supplierId: supplierId,
      packageId: packageId,
      eventName: eventName,
      eventType: 'Casamento',
      eventDate: weddingDate,
      eventTime: "15:00",
      status: BookingStatus.pending,
      totalAmount: totalMoney.amount,
      paidAmount: 0,
      currency: totalMoney.currency,
      payments: [],
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );

    // Step 4: Create the booking
    return await _createBooking(booking);
  }
}

// Usage
void main() async {
  final service = BookingService(createBooking, checkAvailability);

  final result = await service.createWeddingBooking(
    clientId: 'client_123',
    supplierId: 'supplier_456',
    packageId: 'package_789',
    weddingDate: DateTime(2024, 6, 15),
    eventName: 'Casamento de Maria & João',
    packagePrice: 50000000, // 500,000.00 AOA
  );

  result.fold(
    (failure) => print('Erro ao criar booking: ${failure.message}'),
    (booking) => print('Booking criado com sucesso! ID: ${booking.id}'),
  );
}
```

---

## Payment Scenarios

### Scenario 1: Processing Initial Deposit (30%)

```dart
class PaymentService {
  /// Process a 30% deposit payment
  Future<PaymentStatus> processDeposit(BookingEntity booking) async {
    // Create payment status from booking
    final paymentStatus = PaymentStatus(
      totalAmount: Money(amount: booking.totalAmount, currency: booking.currency),
      paidAmount: Money(amount: booking.paidAmount, currency: booking.currency),
    );

    // Calculate 30% deposit
    final depositRequired = paymentStatus.minimumPaymentForPercentage(30.0);

    print('Depósito necessário (30%): ${depositRequired.format()}');
    print('Status atual: ${paymentStatus.statusTextPt}');

    return paymentStatus;
  }

  /// Record a deposit payment
  PaymentStatus recordDeposit(
    BookingEntity booking,
    Money depositAmount,
  ) {
    final currentStatus = PaymentStatus(
      totalAmount: Money(amount: booking.totalAmount, currency: booking.currency),
      paidAmount: Money(amount: booking.paidAmount, currency: booking.currency),
    );

    // Validate deposit
    if (!currentStatus.canPayAmount(depositAmount)) {
      throw ValidationException('Valor de pagamento inválido');
    }

    // Calculate minimum 30% deposit
    final minimumDeposit = currentStatus.minimumPaymentForPercentage(30.0);

    if (depositAmount < minimumDeposit) {
      throw ValidationException(
        'Depósito mínimo de 30% é ${minimumDeposit.format()}. '
        'Você tentou pagar ${depositAmount.format()}',
      );
    }

    // Record the payment
    return currentStatus.recordPayment(depositAmount);
  }
}

// Usage
void main() {
  final booking = BookingEntity(
    // ... other properties
    totalAmount: 50000000, // 500,000.00 AOA
    paidAmount: 0,
    currency: 'AOA',
  );

  final service = PaymentService();

  // Calculate required deposit
  final status = service.processDeposit(booking);

  // Make a deposit payment
  try {
    final depositPaid = Money(amount: 15000000); // 150,000.00 AOA (30%)
    final updatedStatus = service.recordDeposit(booking, depositPaid);

    print('Pagamento registrado!');
    print('Total: ${updatedStatus.totalAmount.format()}');
    print('Pago: ${updatedStatus.paidAmount.format()}');
    print('Restante: ${updatedStatus.remainingAmount.format()}');
    print('Progresso: ${updatedStatus.completionPercentage.toStringAsFixed(1)}%');
  } catch (e) {
    print('Erro: $e');
  }
}
```

### Scenario 2: Installment Payment Plan

```dart
class InstallmentPaymentService {
  /// Create a payment plan for a booking
  List<Money> createPaymentPlan({
    required Money totalAmount,
    required int numberOfInstallments,
  }) {
    if (numberOfInstallments <= 0) {
      throw ArgumentError('Number of installments must be positive');
    }

    // Divide total by number of installments
    final installmentAmount = totalAmount / numberOfInstallments;

    // Create list of installments
    final installments = List<Money>.generate(
      numberOfInstallments,
      (_) => installmentAmount,
    );

    // Adjust last installment for rounding differences
    final totalOfInstallments = installments.fold<Money>(
      Money.zero(currency: totalAmount.currency),
      (sum, installment) => sum + installment,
    );

    final difference = totalAmount - totalOfInstallments;
    if (!difference.isZero) {
      installments[numberOfInstallments - 1] =
          installments[numberOfInstallments - 1] + difference;
    }

    return installments;
  }

  /// Track payment progress through installments
  Map<String, dynamic> getPaymentProgress({
    required PaymentStatus status,
    required List<Money> installments,
  }) {
    var remainingToPay = status.remainingAmount;
    final paidInstallments = <int>[];
    final partialInstallment = <int, Money>{};

    for (var i = 0; i < installments.length; i++) {
      if (remainingToPay.isZero || remainingToPay.isNegative) {
        paidInstallments.add(i);
      } else if (remainingToPay < installments[i]) {
        partialInstallment[i] = installments[i] - remainingToPay;
        break;
      } else {
        paidInstallments.add(i);
        remainingToPay = remainingToPay - installments[i];
      }
    }

    return {
      'total_installments': installments.length,
      'paid_installments': paidInstallments.length,
      'partial_installment': partialInstallment,
      'completion_percentage': status.completionPercentage,
    };
  }
}

// Usage
void main() {
  final service = InstallmentPaymentService();

  final totalPrice = Money(amount: 50000000, currency: 'AOA'); // 500k AOA

  // Create 4-installment plan
  final installments = service.createPaymentPlan(
    totalAmount: totalPrice,
    numberOfInstallments: 4,
  );

  print('Plano de Pagamento (4 parcelas):');
  for (var i = 0; i < installments.length; i++) {
    print('Parcela ${i + 1}: ${installments[i].format()}');
  }

  // After paying 2.5 installments
  final paidSoFar = Money(amount: 31250000); // 312,500.00 AOA
  final status = PaymentStatus(
    totalAmount: totalPrice,
    paidAmount: paidSoFar,
  );

  final progress = service.getPaymentProgress(
    status: status,
    installments: installments,
  );

  print('\nProgresso:');
  print('Parcelas pagas: ${progress['paid_installments']}/${progress['total_installments']}');
  print('Completo: ${progress['completion_percentage'].toStringAsFixed(1)}%');
}
```

---

## Status Management

### Scenario: Supplier Confirms and Completes Booking

```dart
class BookingStatusService {
  final UpdateBookingStatus _updateStatus;

  BookingStatusService(this._updateStatus);

  /// Confirm a pending booking
  Future<Either<Failure, BookingEntity>> confirmBooking({
    required BookingEntity booking,
    required String supplierId,
  }) async {
    // Validate current status
    if (booking.status != BookingStatus.pending) {
      return Left(ValidationFailure(
        'Apenas reservas pendentes podem ser confirmadas. '
        'Status atual: ${booking.status.displayName}',
      ));
    }

    // Validate payment (require at least 30% deposit)
    final paymentStatus = PaymentStatus(
      totalAmount: Money(amount: booking.totalAmount),
      paidAmount: Money(amount: booking.paidAmount),
    );

    if (paymentStatus.completionPercentage < 30.0) {
      return Left(ValidationFailure(
        'Depósito mínimo de 30% necessário para confirmação. '
        'Atual: ${paymentStatus.completionPercentage.toStringAsFixed(1)}%',
      ));
    }

    // Update to confirmed
    final params = UpdateBookingStatusParams(
      bookingId: booking.id,
      newStatus: BookingStatus.confirmed,
      userId: supplierId,
    );

    return await _updateStatus(params);
  }

  /// Mark booking as in progress (event started)
  Future<Either<Failure, BookingEntity>> startEvent({
    required BookingEntity booking,
    required String supplierId,
  }) async {
    // Validate status
    if (booking.status != BookingStatus.confirmed) {
      return Left(ValidationFailure(
        'Apenas reservas confirmadas podem ser iniciadas',
      ));
    }

    // Validate date
    final bookingDate = BookingDate(eventDate: booking.eventDate);
    if (!bookingDate.isToday && bookingDate.isFuture) {
      return Left(ValidationFailure(
        'O evento ainda não começou. Data: ${bookingDate.formatDate()}',
      ));
    }

    final params = UpdateBookingStatusParams(
      bookingId: booking.id,
      newStatus: BookingStatus.inProgress,
      userId: supplierId,
    );

    return await _updateStatus(params);
  }

  /// Complete a booking after event
  Future<Either<Failure, BookingEntity>> completeBooking({
    required BookingEntity booking,
    required String supplierId,
  }) async {
    // Validate status
    if (booking.status != BookingStatus.inProgress) {
      return Left(ValidationFailure(
        'Apenas eventos em andamento podem ser concluídos',
      ));
    }

    // Validate full payment
    final paymentStatus = PaymentStatus(
      totalAmount: Money(amount: booking.totalAmount),
      paidAmount: Money(amount: booking.paidAmount),
    );

    if (!paymentStatus.isFullyPaid) {
      return Left(ValidationFailure(
        'Pagamento completo necessário para conclusão. '
        'Faltam: ${paymentStatus.remainingAmount.format()}',
      ));
    }

    final params = UpdateBookingStatusParams(
      bookingId: booking.id,
      newStatus: BookingStatus.completed,
      userId: supplierId,
    );

    return await _updateStatus(params);
  }
}
```

---

## Date Validation

### Scenario: Validate Booking Dates with Business Rules

```dart
class BookingDateValidator {
  /// Validate wedding booking dates
  ValidationResult validateWeddingDate(DateTime proposedDate) {
    final bookingDate = BookingDate(eventDate: proposedDate);

    // Rule 1: Must be at least 30 days in advance
    if (!bookingDate.isValidForBooking(minimumAdvanceDays: 30)) {
      return ValidationResult.failure(
        'Casamentos requerem pelo menos 30 dias de antecedência. '
        'Data selecionada: ${bookingDate.formatDate()} '
        '(${bookingDate.daysUntilEvent} dias)',
      );
    }

    // Rule 2: Cannot be in the past
    if (bookingDate.isPast) {
      return ValidationResult.failure(
        'Não é possível agendar em datas passadas',
      );
    }

    // Rule 3: Preferred days (Friday-Sunday for weddings)
    final weekday = proposedDate.weekday;
    if (weekday < DateTime.friday) {
      return ValidationResult.warning(
        'A maioria dos casamentos acontece de sexta a domingo. '
        'Tem certeza da data ${bookingDate.formatDate()}?',
      );
    }

    return ValidationResult.success(
      'Data válida: ${bookingDate.formatDate()}',
    );
  }

  /// Validate birthday party booking dates
  ValidationResult validateBirthdayDate(DateTime proposedDate) {
    final bookingDate = BookingDate(eventDate: proposedDate);

    // Birthday parties can be booked with less advance notice
    if (!bookingDate.isValidForBooking(minimumAdvanceDays: 7)) {
      return ValidationResult.failure(
        'Festas de aniversário requerem pelo menos 7 dias de antecedência',
      );
    }

    return ValidationResult.success();
  }

  /// Check if cancellation is allowed based on date
  ValidationResult validateCancellation(BookingEntity booking) {
    final bookingDate = BookingDate(eventDate: booking.eventDate);

    // Rule: Can cancel up to 7 days before event
    if (!bookingDate.isWithinCancellationPeriod(minimumDays: 7)) {
      return ValidationResult.failure(
        'Cancelamento não permitido. O evento está a '
        '${bookingDate.daysUntilEvent} dias. '
        'Cancelamentos devem ser feitos com pelo menos 7 dias de antecedência.',
      );
    }

    // Rule: Cannot cancel completed bookings
    if (booking.status == BookingStatus.completed) {
      return ValidationResult.failure(
        'Não é possível cancelar reservas concluídas',
      );
    }

    return ValidationResult.success(
      'Cancelamento permitido. Evento em ${bookingDate.getRelativeDescription()}',
    );
  }
}

class ValidationResult {
  final bool isValid;
  final String message;
  final ValidationLevel level;

  const ValidationResult({
    required this.isValid,
    required this.message,
    this.level = ValidationLevel.error,
  });

  factory ValidationResult.success([String message = '']) {
    return ValidationResult(
      isValid: true,
      message: message,
      level: ValidationLevel.success,
    );
  }

  factory ValidationResult.failure(String message) {
    return ValidationResult(
      isValid: false,
      message: message,
      level: ValidationLevel.error,
    );
  }

  factory ValidationResult.warning(String message) {
    return ValidationResult(
      isValid: true,
      message: message,
      level: ValidationLevel.warning,
    );
  }
}

enum ValidationLevel { success, warning, error }
```

---

## Availability Checking

### Scenario: Find Next Available Dates

```dart
class AvailabilityService {
  final CheckAvailability _checkAvailability;

  AvailabilityService(this._checkAvailability);

  /// Find the next N available dates for a supplier
  Future<List<DateTime>> findNextAvailableDates({
    required String supplierId,
    required int numberOfDates,
    int minimumAdvanceDays = 7,
    int searchWindowDays = 90,
  }) async {
    final availableDates = <DateTime>[];
    final startDate = DateTime.now().add(Duration(days: minimumAdvanceDays));

    for (var i = 0; i < searchWindowDays && availableDates.length < numberOfDates; i++) {
      final dateToCheck = startDate.add(Duration(days: i));

      // Skip if not a weekend (for wedding suppliers)
      if (dateToCheck.weekday < DateTime.friday) {
        continue;
      }

      final params = CheckAvailabilityParams(
        supplierId: supplierId,
        date: dateToCheck,
      );

      final result = await _checkAvailability(params);

      await result.fold(
        (failure) => null,
        (isAvailable) {
          if (isAvailable) {
            availableDates.add(dateToCheck);
          }
        },
      );
    }

    return availableDates;
  }

  /// Suggest alternative dates when requested date is unavailable
  Future<List<DateTime>> suggestAlternativeDates({
    required String supplierId,
    required DateTime requestedDate,
    int numberOfAlternatives = 3,
  }) async {
    final alternatives = <DateTime>[];

    // Check 2 weeks before and after requested date
    final searchDates = <DateTime>[
      // Week before
      requestedDate.subtract(const Duration(days: 7)),
      requestedDate.subtract(const Duration(days: 14)),
      // Week after
      requestedDate.add(const Duration(days: 7)),
      requestedDate.add(const Duration(days: 14)),
      // 2 weeks after
      requestedDate.add(const Duration(days: 21)),
    ];

    for (final date in searchDates) {
      if (alternatives.length >= numberOfAlternatives) break;

      final params = CheckAvailabilityParams(
        supplierId: supplierId,
        date: date,
      );

      final result = await _checkAvailability(params);

      await result.fold(
        (failure) => null,
        (isAvailable) {
          if (isAvailable) {
            alternatives.add(date);
          }
        },
      );
    }

    return alternatives;
  }
}

// Usage
void main() async {
  final service = AvailabilityService(checkAvailability);

  // Find next 5 available weekend dates
  final availableDates = await service.findNextAvailableDates(
    supplierId: 'supplier_123',
    numberOfDates: 5,
    minimumAdvanceDays: 30,
  );

  print('Próximas datas disponíveis:');
  for (final date in availableDates) {
    final bookingDate = BookingDate(eventDate: date);
    print('- ${bookingDate.formatDate()} (${bookingDate.getRelativeDescription()})');
  }

  // If requested date is unavailable, suggest alternatives
  final requestedDate = DateTime(2024, 6, 15);
  final alternatives = await service.suggestAlternativeDates(
    supplierId: 'supplier_123',
    requestedDate: requestedDate,
  );

  if (alternatives.isNotEmpty) {
    print('\nDatas alternativas:');
    for (final date in alternatives) {
      final bookingDate = BookingDate(eventDate: date);
      print('- ${bookingDate.formatDate()}');
    }
  }
}
```

---

## Error Handling Patterns

### Pattern 1: Graceful Degradation

```dart
class BookingListService {
  final GetClientBookings _getClientBookings;

  /// Get bookings with fallback to empty list
  Future<List<BookingEntity>> getBookingsOrEmpty(String clientId) async {
    final params = GetClientBookingsParams(clientId: clientId);
    final result = await _getClientBookings(params);

    return result.fold(
      (failure) {
        // Log error but return empty list
        print('Error loading bookings: ${failure.message}');
        return <BookingEntity>[];
      },
      (bookings) => bookings,
    );
  }
}
```

### Pattern 2: Retry Logic

```dart
class BookingServiceWithRetry {
  final CreateBooking _createBooking;

  Future<Either<Failure, BookingEntity>> createWithRetry(
    BookingEntity booking, {
    int maxAttempts = 3,
    Duration delayBetweenAttempts = const Duration(seconds: 2),
  }) async {
    for (var attempt = 1; attempt <= maxAttempts; attempt++) {
      final result = await _createBooking(booking);

      final shouldRetry = result.fold(
        (failure) {
          if (failure is ServerFailure && attempt < maxAttempts) {
            print('Attempt $attempt failed, retrying...');
            return true;
          }
          return false;
        },
        (_) => false,
      );

      if (!shouldRetry) {
        return result;
      }

      await Future.delayed(delayBetweenAttempts);
    }

    return Left(ServerFailure('Failed after $maxAttempts attempts'));
  }
}
```

### Pattern 3: Detailed Error Reporting

```dart
class BookingErrorHandler {
  String getDetailedError(Failure failure) {
    if (failure is ValidationFailure) {
      return '''
      Erro de Validação

      ${failure.message}

      Por favor, verifique os dados e tente novamente.
      ''';
    }

    if (failure is ServerFailure) {
      return '''
      Erro do Servidor

      ${failure.message}

      Tente novamente em alguns instantes. Se o problema persistir,
      entre em contato com o suporte.
      ''';
    }

    return 'Erro desconhecido: ${failure.message}';
  }

  void handleBookingError(
    Failure failure, {
    required VoidCallback onRetry,
    required VoidCallback onCancel,
  }) {
    final message = getDetailedError(failure);

    // Show dialog or notification with message
    print(message);

    if (failure is ServerFailure) {
      // Offer retry option
      print('Deseja tentar novamente?');
      onRetry();
    } else {
      onCancel();
    }
  }
}
```

---

## Summary

These examples demonstrate:

1. **Complete workflows** - End-to-end booking creation
2. **Payment handling** - Deposits, installments, validation
3. **Status transitions** - Moving through booking lifecycle
4. **Date validation** - Business rules for different event types
5. **Availability** - Finding and suggesting dates
6. **Error handling** - Graceful degradation and retry patterns

All examples follow Clean Architecture principles:
- Use domain entities and value objects
- Depend on use cases and repository interfaces
- Handle errors with Either/Failure pattern
- Contain no UI or infrastructure code

