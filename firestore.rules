rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ==================== HELPER FUNCTIONS ====================

    // Check if user owns supplier profile
    function isSupplierOwner(supplierId) {
      return request.auth != null &&
        (request.auth.uid == supplierId ||
         request.auth.uid == get(/databases/$(database)/documents/suppliers/$(supplierId)).data.userId);
    }

    // Validate string length
    function validStringLength(str, minLen, maxLen) {
      return str is string && str.size() >= minLen && str.size() <= maxLen;
    }

    // Validate price is positive integer
    function validPrice(price) {
      return price is int && price >= 0;
    }

    // ==================== ADMIN HELPER ====================
    // SECURITY: Admin check uses custom claims ONLY
    // Custom claims must be set via Firebase Admin SDK
    // Legacy Firestore-based admin checks have been removed for security
    function isAdmin() {
      return request.auth != null &&
        request.auth.token.admin == true;
    }

    // Alias for backwards compatibility with existing rules
    // All admin checks now use custom claims only
    function isAdminCombined() {
      return isAdmin();
    }

    // Users collection - users can read/write their own data
    match /users/{userId} {
      // Public read but hide sensitive contact information
      allow read: if request.auth != null;

      // Allow users to create their own account
      // PHASE 0 FIX: Cannot set role or isAdmin on creation
      allow create: if request.auth != null && request.auth.uid == userId &&
        request.resource.data.keys().hasAll(['userType']) &&
        // SECURITY: Cannot set admin fields on creation
        !request.resource.data.keys().hasAny(['role', 'isAdmin']) &&
        // Phone can be null for Google sign-in, but must be string if provided
        (!request.resource.data.keys().hasAny(['phone']) ||
         request.resource.data.phone == null ||
         request.resource.data.phone is string) &&
        // Email can be null, but must be string if provided
        (!request.resource.data.keys().hasAny(['email']) ||
         request.resource.data.email == null ||
         request.resource.data.email is string) &&
        // UserType must be either 'client' or 'supplier'
        request.resource.data.userType in ['client', 'supplier'];

      // Allow users to update their own data with restrictions
      // PHASE 0 FIX: Cannot modify role or isAdmin fields
      allow update: if request.auth != null && request.auth.uid == userId &&
        // SECURITY: Cannot modify admin privilege fields
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'isAdmin']) &&
        // Prevent users from manually setting rating above 5.0 or making themselves active if suspended
        (!request.resource.data.keys().hasAny(['rating']) ||
         (request.resource.data.rating >= 0 && request.resource.data.rating <= 5.0)) &&
        // Cannot bypass suspension by setting isActive to true (only check if document exists)
        (!request.resource.data.keys().hasAny(['isActive', 'suspension']) ||
         !exists(/databases/$(database)/documents/users/$(userId)) ||
         resource.data.isActive == true) &&
        // Allow adding phone if it doesn't exist, but prevent changing if it does (only check if document exists)
        (!exists(/databases/$(database)/documents/users/$(userId)) ||
         !resource.data.keys().hasAny(['phone']) ||
         resource.data.phone == null ||
         resource.data.phone == '' ||
         !request.resource.data.keys().hasAny(['phone']) ||
         request.resource.data.phone == null ||
         request.resource.data.phone == resource.data.phone) &&
        // Allow adding email if it doesn't exist, but prevent changing if it does (only check if document exists)
        (!exists(/databases/$(database)/documents/users/$(userId)) ||
         !resource.data.keys().hasAny(['email']) ||
         resource.data.email == null ||
         resource.data.email == '' ||
         !request.resource.data.keys().hasAny(['email']) ||
         request.resource.data.email == null ||
         request.resource.data.email == resource.data.email);

      // Allow users to delete their own account
      allow delete: if request.auth != null && request.auth.uid == userId;

      // Violations subcollection - read-only for user, write by system
      match /violations/{violationId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow write: if false; // Only backend/Cloud Functions can write violations
      }
    }

    // Suppliers collection - authenticated users can create, owners can update
    match /suppliers/{supplierId} {
      // Public read for browsing BUT hide contact information
      allow read: if true;

      allow create: if request.auth != null &&
        // Set initial rating to 5.0 on creation
        (!request.resource.data.keys().hasAny(['rating']) ||
         request.resource.data.rating == 5.0) &&
        // PHASE 0 FIX: Cannot set stats fields on creation
        !request.resource.data.keys().hasAny(['viewCount', 'leadCount', 'favoriteCount',
          'confirmedBookings', 'completedBookings', 'totalBookings']);

      // PHASE 0 FIX: Removed client-side stats updates
      // Stats fields can ONLY be updated by Cloud Functions (not enforced here, CF uses admin SDK)
      allow update: if request.auth != null &&
        (isSupplierOwner(supplierId) || isAdminCombined()) &&
        // Prevent suppliers from manually inflating their rating (admins can set any rating)
        (isAdminCombined() || !request.resource.data.keys().hasAny(['rating']) ||
         request.resource.data.rating <= 5.0) &&
        // PHASE 0 FIX: Block client writes to stats fields
        (isAdminCombined() || !request.resource.data.diff(resource.data).affectedKeys()
          .hasAny(['viewCount', 'leadCount', 'favoriteCount', 'confirmedBookings',
                   'completedBookings', 'totalBookings']));

      // Supplier owner OR admin can delete
      allow delete: if request.auth != null && (isSupplierOwner(supplierId) || isAdminCombined());

      // Blocked dates subcollection (for availability management)
      match /blocked_dates/{dateId} {
        allow read: if true; // Public read to show unavailable dates
        allow create, update, delete: if request.auth != null && isSupplierOwner(supplierId);
      }

      // Violations subcollection - read-only for supplier owner, write by system
      match /violations/{violationId} {
        allow read: if request.auth != null && isSupplierOwner(supplierId);
        allow write: if false; // Only backend/Cloud Functions can write violations
      }

      // Profile views subcollection - for tracking visitor statistics
      // Any authenticated user can create a view record (not their own supplier)
      match /profile_views/{viewId} {
        allow read: if request.auth != null && isSupplierOwner(supplierId);
        allow create: if request.auth != null &&
          request.resource.data.viewerId == request.auth.uid;
        allow update, delete: if false; // Views are immutable
      }

      // Any other supplier subcollections
      match /{document=**} {
        allow read: if true;
        allow write: if request.auth != null && isSupplierOwner(supplierId);
      }
    }

    // Packages collection - linked to suppliers
    match /packages/{packageId} {
      allow read: if true; // Public read
      allow create: if request.auth != null &&
        // Verify user owns the supplier profile they're creating package for
        exists(/databases/$(database)/documents/suppliers/$(request.resource.data.supplierId)) &&
        isSupplierOwner(request.resource.data.supplierId);
      allow update, delete: if request.auth != null &&
        isSupplierOwner(resource.data.supplierId);
    }

    // Categories collection - public read, admin write
    match /categories/{categoryId} {
      allow read: if true;
      allow write: if isAdminCombined();
    }

    // Admin notifications - only admins can access
    match /admin_notifications/{notificationId} {
      allow read, write: if isAdminCombined();
    }

    // Platform settings - read by authenticated users, write by admins only
    match /platform_settings/{settingId} {
      allow read: if request.auth != null;
      allow write: if isAdminCombined();
    }

    // Supplier onboarding queue - admin only
    match /onboarding_queue/{queueId} {
      allow read, write: if isAdminCombined();
    }

    // Disputes - participants can read, admins can write
    match /disputes/{disputeId} {
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.clientId ||
         request.auth.uid == resource.data.supplierId ||
         isAdminCombined());
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.clientId;
      allow update: if isAdminCombined();
    }

    // Suspensions - admin only
    match /suspensions/{suspensionId} {
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.userId || isAdminCombined());
      allow write: if isAdminCombined();
    }

    // PHASE 0 FIX: Transactions - CF/admin only for create/update
    match /transactions/{transactionId} {
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.clientId ||
         request.auth.uid == resource.data.supplierId ||
         isAdminCombined());
      // SECURITY: Client cannot create or update transactions directly
      allow create: if false; // Cloud Functions only
      allow update: if isAdminCombined();
      allow delete: if false;
    }

    // PHASE 1.2 + 2.3A LOCKDOWN: Bookings collection - Cloud Functions ONLY for writes
    // Booking lifecycle managed by Cloud Functions:
    // - createBooking: Server-side creation with atomic conflict checking
    // - updateBookingStatus: Server-side state machine validation
    // - cancelBooking: Server-side cancellation with authorization
    match /bookings/{bookingId} {
      // Helper to check if user is the supplier owner for this booking
      function isBookingSupplierOwner() {
        return exists(/databases/$(database)/documents/suppliers/$(resource.data.supplierId)) &&
          get(/databases/$(database)/documents/suppliers/$(resource.data.supplierId)).data.userId == request.auth.uid;
      }

      // READ: Only participants (client, supplier owner) or admin can read
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.clientId ||
         isBookingSupplierOwner() ||
         isAdminCombined());

      // SECURITY: All writes DENIED - Cloud Functions (Admin SDK) only
      // Booking creation must use createBooking Cloud Function
      // This ensures atomic conflict checking and server-side validation
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // PHASE 1.3 LOCKDOWN: Reviews collection - Cloud Functions ONLY for writes
    // All review creation must go through createReview Cloud Function
    // This ensures: completed booking validation, one review per booking, stats integrity
    match /reviews/{reviewId} {
      // READ: Public read for displaying reviews
      allow read: if true;

      // SECURITY: All writes DENIED - Cloud Functions (Admin SDK) only
      // Review creation must use createReview Cloud Function
      // This prevents: fake reviews, duplicate reviews, stats manipulation
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // Favorites collection - user can only access their own
    match /favorites/{favoriteId} {
      // Allow reading own favorites by document ID or by query
      allow read: if request.auth != null &&
        (request.auth.uid == favoriteId.split('_')[0] || // Document read by ID
         resource.data.userId == request.auth.uid); // Query by userId field
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId;
      allow update, delete: if request.auth != null &&
        (favoriteId.split('_')[0] == request.auth.uid ||
         (exists(/databases/$(database)/documents/favorites/$(favoriteId)) &&
          get(/databases/$(database)/documents/favorites/$(favoriteId)).data.userId == request.auth.uid));
    }

    // Conversations collection - only participants can access
    match /conversations/{conversationId} {
      // Helper to check if user's supplier doc ID is in participants
      function isSupplierInConversationParticipants() {
        return resource.data.participants.size() >= 1 &&
          (
            (exists(/databases/$(database)/documents/suppliers/$(resource.data.participants[0])) &&
             get(/databases/$(database)/documents/suppliers/$(resource.data.participants[0])).data.userId == request.auth.uid) ||
            (resource.data.participants.size() >= 2 &&
             exists(/databases/$(database)/documents/suppliers/$(resource.data.participants[1])) &&
             get(/databases/$(database)/documents/suppliers/$(resource.data.participants[1])).data.userId == request.auth.uid)
          );
      }

      // Allow read if authenticated OR if document doesn't exist (for existence checks)
      // The app checks if conversation exists in this collection before falling back to legacy chats
      allow read: if request.auth != null &&
        (resource == null ||  // Document doesn't exist - allow check
         request.auth.uid in resource.data.participants ||
         request.auth.uid == resource.data.clientId ||
         (resource.data.keys().hasAny(['supplierId']) && isSupplierOwner(resource.data.supplierId)) ||
         (resource.data.isSupport == true && request.auth.uid in resource.data.participants) ||
         isSupplierInConversationParticipants());

      allow create: if request.auth != null &&
        request.auth.uid in request.resource.data.participants;

      allow update: if request.auth != null &&
        (request.auth.uid in resource.data.participants ||
         request.auth.uid == resource.data.clientId ||
         (resource.data.keys().hasAny(['supplierId']) && isSupplierOwner(resource.data.supplierId)) ||
         isSupplierInConversationParticipants());

      // Conversation messages subcollection
      match /messages/{messageId} {
        // Helper to check if user's supplier doc ID is in conversation participants
        function isSupplierInConvMsgParticipants() {
          let convDoc = get(/databases/$(database)/documents/conversations/$(conversationId)).data;
          return convDoc.participants.size() >= 1 &&
            (
              (exists(/databases/$(database)/documents/suppliers/$(convDoc.participants[0])) &&
               get(/databases/$(database)/documents/suppliers/$(convDoc.participants[0])).data.userId == request.auth.uid) ||
              (convDoc.participants.size() >= 2 &&
               exists(/databases/$(database)/documents/suppliers/$(convDoc.participants[1])) &&
               get(/databases/$(database)/documents/suppliers/$(convDoc.participants[1])).data.userId == request.auth.uid)
            );
        }

        allow read: if request.auth != null &&
          (resource == null ||  // Message doesn't exist - allow check
           request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants ||
           request.auth.uid == get(/databases/$(database)/documents/conversations/$(conversationId)).data.clientId ||
           (get(/databases/$(database)/documents/conversations/$(conversationId)).data.keys().hasAny(['supplierId']) &&
            isSupplierOwner(get(/databases/$(database)/documents/conversations/$(conversationId)).data.supplierId)) ||
           isSupplierInConvMsgParticipants());
        allow create: if request.auth != null &&
          (request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants ||
           request.auth.uid == get(/databases/$(database)/documents/conversations/$(conversationId)).data.clientId ||
           (get(/databases/$(database)/documents/conversations/$(conversationId)).data.keys().hasAny(['supplierId']) &&
            isSupplierOwner(get(/databases/$(database)/documents/conversations/$(conversationId)).data.supplierId)) ||
           isSupplierInConvMsgParticipants());
      }
    }

    // Broadcasts collection - admin can create, users can read/mark as read
    match /broadcasts/{broadcastId} {
      allow read: if request.auth != null;
      allow create: if isAdminCombined();
      allow update: if request.auth != null &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy', 'dismissedBy']);
      allow delete: if isAdminCombined();
    }

    // Broadcast markers collection - for tracking broadcast delivery
    match /broadcast_markers/{markerId} {
      allow read: if request.auth != null;
      allow write: if isAdminCombined();
    }

    // Legacy chats collection - only participants can access
    // NOTE: Some legacy conversations may have supplier document ID instead of auth UID in participants
    match /chats/{chatId} {
      // Helper to check if user's supplier doc ID is in participants
      // This handles cases where participants has supplier doc ID instead of auth UID
      function isSupplierInParticipants() {
        // Check if any participant is a supplier doc where user is the owner
        return resource.data.participants.size() >= 1 &&
          (
            // Check first participant
            (exists(/databases/$(database)/documents/suppliers/$(resource.data.participants[0])) &&
             get(/databases/$(database)/documents/suppliers/$(resource.data.participants[0])).data.userId == request.auth.uid) ||
            // Check second participant (if exists)
            (resource.data.participants.size() >= 2 &&
             exists(/databases/$(database)/documents/suppliers/$(resource.data.participants[1])) &&
             get(/databases/$(database)/documents/suppliers/$(resource.data.participants[1])).data.userId == request.auth.uid)
          );
      }

      // Allow read if user is in participants array OR is the client OR owns the supplier
      allow read: if request.auth != null &&
        (request.auth.uid in resource.data.participants ||
         request.auth.uid == resource.data.clientId ||
         request.auth.uid == resource.data.supplierId ||
         (resource.data.keys().hasAny(['supplierId']) && isSupplierOwner(resource.data.supplierId)) ||
         isSupplierInParticipants());
      allow create: if request.auth != null &&
        request.auth.uid in request.resource.data.participants;
      allow update: if request.auth != null &&
        (request.auth.uid in resource.data.participants ||
         request.auth.uid == resource.data.clientId ||
         (resource.data.keys().hasAny(['supplierId']) && isSupplierOwner(resource.data.supplierId)) ||
         isSupplierInParticipants());

      match /messages/{messageId} {
        // Helper to check if user's supplier doc ID is in chat participants
        function isSupplierInChatParticipants() {
          let chatDoc = get(/databases/$(database)/documents/chats/$(chatId)).data;
          return chatDoc.participants.size() >= 1 &&
            (
              (exists(/databases/$(database)/documents/suppliers/$(chatDoc.participants[0])) &&
               get(/databases/$(database)/documents/suppliers/$(chatDoc.participants[0])).data.userId == request.auth.uid) ||
              (chatDoc.participants.size() >= 2 &&
               exists(/databases/$(database)/documents/suppliers/$(chatDoc.participants[1])) &&
               get(/databases/$(database)/documents/suppliers/$(chatDoc.participants[1])).data.userId == request.auth.uid)
            );
        }

        allow read: if request.auth != null &&
          (request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants ||
           request.auth.uid == get(/databases/$(database)/documents/chats/$(chatId)).data.clientId ||
           (get(/databases/$(database)/documents/chats/$(chatId)).data.keys().hasAny(['supplierId']) &&
            isSupplierOwner(get(/databases/$(database)/documents/chats/$(chatId)).data.supplierId)) ||
           isSupplierInChatParticipants());
        allow create: if request.auth != null &&
          (request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants ||
           request.auth.uid == get(/databases/$(database)/documents/chats/$(chatId)).data.clientId ||
           (get(/databases/$(database)/documents/chats/$(chatId)).data.keys().hasAny(['supplierId']) &&
            isSupplierOwner(get(/databases/$(database)/documents/chats/$(chatId)).data.supplierId)) ||
           isSupplierInChatParticipants());
      }
    }

    // Notifications collection - user can only access their own
    match /notifications/{notificationId} {
      allow read, delete: if request.auth != null &&
        request.auth.uid == resource.data.userId;
      allow create: if request.auth != null;
      allow update: if request.auth != null &&
        request.auth.uid == resource.data.userId;
    }

    // Cart collection - user can only access their own cart
    match /users/{userId}/cart/{cartItemId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId &&
        request.resource.data.keys().hasAll(['packageId', 'packageName', 'supplierId', 'supplierName', 'selectedDate', 'guestCount', 'basePrice', 'totalPrice', 'addedAt']) &&
        request.resource.data.packageId is string &&
        request.resource.data.packageName is string &&
        request.resource.data.supplierId is string &&
        request.resource.data.supplierName is string &&
        request.resource.data.selectedDate is timestamp &&
        request.resource.data.guestCount is int &&
        request.resource.data.guestCount > 0 &&
        request.resource.data.basePrice is int &&
        request.resource.data.basePrice >= 0 &&
        request.resource.data.totalPrice is int &&
        request.resource.data.totalPrice >= 0 &&
        request.resource.data.addedAt is timestamp;
      allow update: if request.auth != null && request.auth.uid == userId &&
        request.resource.data.packageId == resource.data.packageId &&
        request.resource.data.supplierId == resource.data.supplierId;
      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    // Appeals collection - suspended users can appeal
    match /appeals/{appealId} {
      allow read: if request.auth != null &&
        request.auth.uid == resource.data.userId;
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId &&
        request.resource.data.keys().hasAll(['userId', 'message', 'submittedAt', 'status']) &&
        request.resource.data.status == 'pending';
      allow update: if false;
      allow delete: if false;
    }

    // ==================== SECURITY & AUDIT COLLECTIONS ====================

    // Audit logs - WRITE ONLY from client (append-only), read by admin
    match /audit_logs/{logId} {
      allow read: if isAdminCombined();
      allow create: if request.auth != null &&
        request.resource.data.keys().hasAll(['category', 'eventType', 'timestamp']) &&
        request.resource.data.userId == request.auth.uid;
      allow update, delete: if false;
    }

    // User sessions - for security monitoring
    match /user_sessions/{sessionId} {
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.userId || isAdminCombined());
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId;
      allow update: if request.auth != null &&
        request.auth.uid == resource.data.userId;
      allow delete: if request.auth != null &&
        (request.auth.uid == resource.data.userId || isAdminCombined());
    }

    // PHASE 1.4 LOCKDOWN: Rate limits - Cloud Functions ONLY
    // Rate limit data is managed exclusively by Cloud Functions (Admin SDK)
    // Clients cannot read or write rate limits to prevent bypass attacks
    match /rate_limits/{userId} {
      // SECURITY: All access DENIED - Cloud Functions (Admin SDK) only
      allow read: if false;
      allow write: if false;

      // Subcollection for action-specific counters
      match /actions/{actionKey} {
        allow read: if false;
        allow write: if false;
      }
    }

    // Verification documents - sensitive supplier documents
    match /verification_documents/{documentId} {
      allow read: if request.auth != null &&
        (isSupplierOwner(resource.data.supplierId) || isAdminCombined());
      allow create: if request.auth != null &&
        isSupplierOwner(request.resource.data.supplierId);
      allow update: if isAdminCombined();
      allow delete: if request.auth != null &&
        (isSupplierOwner(resource.data.supplierId) || isAdminCombined());
    }

    // PHASE 0 FIX: Payment Methods - owner only, no cross-user access
    match /paymentMethods/{paymentMethodId} {
      function ownsPaymentMethod() {
        return request.auth != null &&
          exists(/databases/$(database)/documents/suppliers/$(resource.data.supplierId)) &&
          isSupplierOwner(resource.data.supplierId);
      }

      function ownsPaymentMethodCreate() {
        return request.auth != null &&
          exists(/databases/$(database)/documents/suppliers/$(request.resource.data.supplierId)) &&
          isSupplierOwner(request.resource.data.supplierId);
      }

      // PHASE 0 FIX: Only owner can read their payment methods
      allow read: if request.auth != null && (ownsPaymentMethod() || isAdminCombined());

      allow create: if request.auth != null &&
        ownsPaymentMethodCreate() &&
        request.resource.data.keys().hasAll(['supplierId', 'type', 'displayName', 'details', 'isDefault', 'createdAt', 'updatedAt']) &&
        request.resource.data.type in ['creditCard', 'multicaixaExpress', 'bankTransfer'] &&
        request.resource.data.supplierId is string &&
        request.resource.data.displayName.size() > 0 &&
        request.resource.data.details is map &&
        request.resource.data.isDefault is bool &&
        request.resource.data.createdAt is timestamp &&
        request.resource.data.updatedAt is timestamp;

      allow update: if request.auth != null &&
        ownsPaymentMethod() &&
        request.resource.data.supplierId == resource.data.supplierId &&
        request.resource.data.type in ['creditCard', 'multicaixaExpress', 'bankTransfer'] &&
        request.resource.data.updatedAt is timestamp;

      allow delete: if request.auth != null && ownsPaymentMethod();
    }

    // ==================== ADMIN 2FA COLLECTIONS ====================

    match /admin_2fa_sessions/{sessionId} {
      allow read: if request.auth != null &&
        resource.data.adminId == request.auth.uid;
      allow create: if request.auth != null &&
        request.resource.data.adminId == request.auth.uid;
      allow update: if request.auth != null &&
        resource.data.adminId == request.auth.uid;
      allow delete: if request.auth != null &&
        resource.data.adminId == request.auth.uid;
    }

    match /admin_trusted_devices/{deviceId} {
      allow read: if request.auth != null &&
        resource.data.adminId == request.auth.uid;
      allow create: if request.auth != null &&
        request.resource.data.adminId == request.auth.uid;
      allow update: if false;
      allow delete: if request.auth != null &&
        resource.data.adminId == request.auth.uid;
    }

    // Trusted devices - for device fingerprinting and multi-device login tracking
    match /trusted_devices/{deviceId} {
      // Format: userId_deviceFingerprint
      allow read: if request.auth != null &&
        (deviceId.split('_')[0] == request.auth.uid ||
         resource.data.userId == request.auth.uid);
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid &&
        deviceId.split('_')[0] == request.auth.uid;
      allow update: if request.auth != null &&
        resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null &&
        resource.data.userId == request.auth.uid;
    }

    match /admin_2fa_lockouts/{adminId} {
      allow read: if request.auth != null &&
        request.auth.uid == adminId;
      allow create: if request.auth != null &&
        request.auth.uid == adminId;
      allow update: if request.auth != null &&
        request.auth.uid == adminId;
      allow delete: if request.auth != null &&
        request.auth.uid == adminId;
    }

    match /admin_otp_log/{logId} {
      allow read: if isAdminCombined();
      allow create: if request.auth != null;
      allow update: if false;
      allow delete: if isAdminCombined();
    }

    // Mail collection - for sending emails via Cloud Functions
    match /mail/{mailId} {
      allow create: if request.auth != null;
      allow read, update, delete: if false;
    }

    // Pending verifications - for high-value transaction verification
    match /pending_verifications/{verificationId} {
      allow read: if request.auth != null &&
        resource.data.userId == request.auth.uid;
      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;
      allow update: if request.auth != null &&
        resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null &&
        resource.data.userId == request.auth.uid;
    }

    // Safety scores collection
    match /safetyScores/{userId} {
      allow read: if request.auth != null &&
        request.auth.uid == userId;
      allow create, update: if request.auth != null &&
        request.auth.uid == userId;
      allow delete: if false;
    }

    // Custom offers collection
    match /custom_offers/{offerId} {
      // Check if user owns a supplier whose document ID is the sellerId
      function isSellerOwner() {
        return request.auth.uid == resource.data.sellerId ||
          (exists(/databases/$(database)/documents/suppliers/$(resource.data.sellerId)) &&
           get(/databases/$(database)/documents/suppliers/$(resource.data.sellerId)).data.userId == request.auth.uid);
      }

      // Check if user owns a supplier whose document ID is the sellerId (for CREATE)
      function isSellerOwnerCreate() {
        return request.auth.uid == request.resource.data.sellerId ||
          (exists(/databases/$(database)/documents/suppliers/$(request.resource.data.sellerId)) &&
           get(/databases/$(database)/documents/suppliers/$(request.resource.data.sellerId)).data.userId == request.auth.uid);
      }

      // Check if user is in the chat/conversation (supports both collections)
      function isInChatOrConversationCreate() {
        let chatId = request.resource.data.chatId;
        // Check chats collection first
        return (exists(/databases/$(database)/documents/chats/$(chatId)) &&
                request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants) ||
               // Check conversations collection as fallback
               (exists(/databases/$(database)/documents/conversations/$(chatId)) &&
                request.auth.uid in get(/databases/$(database)/documents/conversations/$(chatId)).data.participants);
      }

      // Check if user's supplier doc is in chat/conversation participants
      function isSupplierInChatOrConversationCreate() {
        let chatId = request.resource.data.chatId;
        // Try chats collection
        let inChats = exists(/databases/$(database)/documents/chats/$(chatId)) &&
          get(/databases/$(database)/documents/chats/$(chatId)).data.participants.size() >= 1 &&
          (
            (exists(/databases/$(database)/documents/suppliers/$(get(/databases/$(database)/documents/chats/$(chatId)).data.participants[0])) &&
             get(/databases/$(database)/documents/suppliers/$(get(/databases/$(database)/documents/chats/$(chatId)).data.participants[0])).data.userId == request.auth.uid) ||
            (get(/databases/$(database)/documents/chats/$(chatId)).data.participants.size() >= 2 &&
             exists(/databases/$(database)/documents/suppliers/$(get(/databases/$(database)/documents/chats/$(chatId)).data.participants[1])) &&
             get(/databases/$(database)/documents/suppliers/$(get(/databases/$(database)/documents/chats/$(chatId)).data.participants[1])).data.userId == request.auth.uid)
          );
        // Try conversations collection
        let inConvs = exists(/databases/$(database)/documents/conversations/$(chatId)) &&
          get(/databases/$(database)/documents/conversations/$(chatId)).data.participants.size() >= 1 &&
          (
            (exists(/databases/$(database)/documents/suppliers/$(get(/databases/$(database)/documents/conversations/$(chatId)).data.participants[0])) &&
             get(/databases/$(database)/documents/suppliers/$(get(/databases/$(database)/documents/conversations/$(chatId)).data.participants[0])).data.userId == request.auth.uid) ||
            (get(/databases/$(database)/documents/conversations/$(chatId)).data.participants.size() >= 2 &&
             exists(/databases/$(database)/documents/suppliers/$(get(/databases/$(database)/documents/conversations/$(chatId)).data.participants[1])) &&
             get(/databases/$(database)/documents/suppliers/$(get(/databases/$(database)/documents/conversations/$(chatId)).data.participants[1])).data.userId == request.auth.uid)
          );
        return inChats || inConvs;
      }

      // Allow reading if user is seller, buyer, or owns seller's supplier doc
      allow read: if request.auth != null &&
        (resource == null ||
         request.auth.uid == resource.data.sellerId ||
         request.auth.uid == resource.data.buyerId ||
         isSellerOwner());

      // Allow create if user is buyer OR owns seller's supplier doc OR is in chat/conversation
      allow create: if request.auth != null &&
        (request.auth.uid == request.resource.data.buyerId ||
         isSellerOwnerCreate() ||
         (request.resource.data.keys().hasAny(['chatId']) &&
          (isInChatOrConversationCreate() || isSupplierInChatOrConversationCreate())));

      // Allow update if user is buyer OR owns seller's supplier doc
      allow update: if request.auth != null &&
        (request.auth.uid == resource.data.buyerId ||
         isSellerOwner());

      allow delete: if false;
    }

    // PHASE 0 FIX: Support conversations - participant or admin only
    match /support_conversations/{conversationId} {
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.userId || isAdminCombined());

      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;

      allow update: if request.auth != null &&
        (request.auth.uid == resource.data.userId || isAdminCombined());

      // PHASE 0 FIX: Messages - participant or admin only
      match /messages/{messageId} {
        allow read: if request.auth != null &&
          (request.auth.uid == get(/databases/$(database)/documents/support_conversations/$(conversationId)).data.userId || isAdminCombined());
        allow create: if request.auth != null &&
          (request.auth.uid == get(/databases/$(database)/documents/support_conversations/$(conversationId)).data.userId || isAdminCombined());
        allow update, delete: if false;
      }
    }

    // Support tickets
    match /support_tickets/{ticketId} {
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.userId || isAdminCombined());

      allow create: if request.auth != null &&
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll(['userId', 'subject', 'description', 'category', 'status', 'createdAt']);

      allow update: if request.auth != null &&
        (request.auth.uid == resource.data.userId || isAdminCombined());

      allow delete: if isAdminCombined();

      match /messages/{messageId} {
        allow read: if request.auth != null &&
          (request.auth.uid == get(/databases/$(database)/documents/support_tickets/$(ticketId)).data.userId || isAdminCombined());
        allow create: if request.auth != null &&
          (request.auth.uid == get(/databases/$(database)/documents/support_tickets/$(ticketId)).data.userId || isAdminCombined());
        allow update, delete: if false;
      }
    }

    // Canned responses - admin-only
    match /canned_responses/{responseId} {
      allow read: if isAdminCombined();
      allow create, update, delete: if isAdminCombined();
    }

    // ==================== PHASE 0: PAYMENTS LOCKDOWN ====================
    // Payments collection - LOCKED until Cloud Functions implemented
    match /payments/{paymentId} {
      // Only admin can read payments
      allow read: if isAdminCombined();
      // SECURITY: Client cannot create/update/delete payments directly
      allow create: if false; // Cloud Functions only
      allow update: if false; // Cloud Functions only
      allow delete: if false;
    }

    // ==================== UI-FIRST PROJECTIONS ====================
    // These collections are maintained by Cloud Functions and are READ-ONLY for UI

    // Client views - aggregated view for client dashboard
    // Contains: bookings, payments, messages summary - all from client's perspective
    match /client_views/{clientId} {
      // Client can only read their own view
      allow read: if request.auth != null && request.auth.uid == clientId;
      // SECURITY: Only Cloud Functions (Admin SDK) can write
      allow create, update, delete: if false;
    }

    // Supplier views - aggregated view for supplier dashboard
    // Contains: bookings, earnings, availability - all from supplier's perspective
    match /supplier_views/{supplierId} {
      // Supplier owner can read their view
      allow read: if request.auth != null && isSupplierOwner(supplierId);
      // SECURITY: Only Cloud Functions (Admin SDK) can write
      allow create, update, delete: if false;
    }

    // Escrow collection - backend only (for projection updates)
    match /escrow/{escrowId} {
      // Only participants can read
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.clientId ||
         request.auth.uid == resource.data.supplierId ||
         isAdminCombined());
      // SECURITY: Only Cloud Functions can write
      allow create, update, delete: if false;
    }

    // ==================== PHASE 0: DENY-BY-DEFAULT ====================
    // Catch-all rule for any undefined collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
